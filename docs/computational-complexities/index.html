<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Computational complexity - The PGM-index</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="icon" href="https://pgm.di.unipi.it/favicon.png">

  
  
  <link rel="stylesheet" href="/css/style.min.4271f647dc62f6408e59c6ef70c4baed6f100ec00a5d55416ba05f76339a49a5.css">
  

  

</head>

<body class='page page-default-single'>
  <div id="main-menu-mobile" class="main-menu-mobile">
  <ul>
    
    
    <li class="menu-item-home">
      <a href="/">
        <span>Home</span>
      </a>
    </li>
    
    <li class="menu-item-docs">
      <a href="/docs/">
        <span>Docs</span>
      </a>
    </li>
    
  </ul>
</div>
  <div class="wrapper">
    <div class='header'>
  <div class="container">
    <div class="logo">
      <a href="https://pgm.di.unipi.it">The PGM-index</a>
    </div>
    <div class="logo-mobile">
      <a href="https://pgm.di.unipi.it">The PGM-index</a>
    </div>
    <div id="main-menu" class="main-menu">
  <ul>
    
    
    <li class="menu-item-home">
      <a href="/">
        <span>Home</span>
      </a>
    </li>
    
    <li class="menu-item-docs">
      <a href="/docs/">
        <span>Docs</span>
      </a>
    </li>
    
  </ul>
</div>
    <button id="toggle-main-menu-mobile" class="hamburger hamburger--slider" type="button">
  <span class="hamburger-box">
    <span class="hamburger-inner"></span>
  </span>
</button>
  </div>
</div>


    
    
    
    
    
    

    
    <div class="container pt-2 pt-md-6 pb-3 pb-md-6">
      <div class="row">
        <div class="col-12 col-md-3 mb-3">
          <div class="sidebar">
            
<div class="docs-menu">
  <h4>Docs</h4>
  <ul>
    
    <li class="">
      <a href="https://pgm.di.unipi.it/docs/building-the-code/">Building the code</a>
    </li>
    
    <li class="">
      <a href="https://pgm.di.unipi.it/docs/tuner/">Using the tuner</a>
    </li>
    
    <li class="">
      <a href="https://pgm.di.unipi.it/docs/cpp-reference/">C&#43;&#43; Reference</a>
    </li>
    
    <li class="">
      <a href="https://pgm.di.unipi.it/docs/python-reference/">Python Reference</a>
    </li>
    
    <li class="active ">
      <a href="https://pgm.di.unipi.it/docs/computational-complexities/">Computational complexity</a>
    </li>
    
  </ul>
</div>

          </div>
        </div>
        <div class="col-12 col-md-9">
          
<h1 class="title">Computational complexity</h1>
<div class="content anchor-link-enabled">
  <style>
.content {
    text-align: justify;
    -webkit-hyphens: auto;
    -ms-hyphens: auto;
    hyphens: auto;
}
</style>
<p>This page summarises the results on the space and time complexity of the PGM-index described in detail in <a href="https://pgm.di.unipi.it/#Publications">our publications</a>.</p>
<p>As model of computation, we do not use the <a href="https://en.wikipedia.org/wiki/Random-access_machine">random-access machine</a> model taught in introductory algorithms textbooks, in which one counts the number of computation steps. What matters in modern machines working on large amounts of data is how algorithms and data structures take advantage of the <a href="https://en.wikipedia.org/wiki/Memory_hierarchy">memory hierarchy</a> and minimise the data-access latency.<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>
Therefore, we use the <em>I/O model of computation</em> (aka the external-memory model or the two-level memory model) defined by the Encyclopedia of Algorithms as follows:</p>
<blockquote>
<p>The <em>input/output model</em> (I/O model) views the computer as consisting of a processor, internal memory (RAM), and external memory (disk). The internal memory is of limited size, large enough to hold $M$ data items. The external memory is of conceptually unlimited size and is divided into blocks of $B$ consecutive data items. All computation has to happen on data in internal memory. Data is brought into internal memory and written back to external memory using I/O operations (I/Os), which are performed explicitly by the algorithm. Each such operation reads or writes one block of data from or to external memory. The complexity of an algorithm in this model is the number of I/Os it performs.</p>
</blockquote>
<p>In a nutshell, assuming that both the $n$ input keys and the PGM-index are kept on disk (we relax this latter assumption below), the PGM-index achieves the following bounds in the worst case:</p>
<style>
p > strong { display: inline-block; width: 23%; word-wrap : break-word; }
</style>
<p><strong>Number of levels:</strong> $\Oh(\log_c m)$<br>
<strong>Point query:</strong> $\Oh((\log_c m) \log_2\frac{\varepsilon}{B})$ I/Os <br>
<strong>Range query:</strong> $\Oh((\log_c m) \log_2\frac{\varepsilon}{B}+\frac{k}{B})$ I/Os, where $k$ is the number of reported keys <br>
<strong>Insertions/deletions:</strong> $\Oh(\log_B n)$ I/Os<br>
<strong>Space of the index:</strong> $\Oh(m)$ memory words, i.e. $\Oh(\frac{m}{B})$ disk pages</p>
<p>where:</p>
<ul>
<li>$n =$ number of input keys</li>
<li>$B =$ disk page size</li>
<li>$\varepsilon =$ user-given maximum error of the piecewise linear approximation, which determines how many keys the index searches at each level</li>
<li>$m =$ number of line segments in the piecewise linear $\varepsilon$-approximation at the core of the PGM-index;<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> it always holds $m \leq \frac{n}{2\varepsilon}$</li>
<li>$c =$ (variable) fan-out of the PGM-index; it always holds $c \geq 2\varepsilon$</li>
</ul>
<p>An interesting setting is when $\varepsilon=\Theta(B)$, i.e. when at each level of the index we need to transfer just $\Oh(1)$ disk pages. Using the fact that $m \leq \frac{n}{2\varepsilon} = \Theta(\frac{n}{B})$,<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup> this gives:</p>
<p><strong>Number of levels:</strong> $\Oh(\log_B n)$<br>
<strong>Point query:</strong> $\Oh(\log_B n)$ I/Os<br>
<strong>Range query:</strong> $\Oh(\log_B n + \frac{k}{B})$ I/Os, where $k$ is the number of reported keys<br>
<strong>Insertions/deletions:</strong> $\Oh(\log_B n)$ I/Os<br>
<strong>Space of the index:</strong> $\Oh(\frac{n}{B})$ memory words, i.e. $\Oh(\frac{n}{B^2})$ disk pages</p>
<p>Overall, the above bounds show that the PGM-index is <em>never</em> worse in space and time complexity than a <a href="https://en.wikipedia.org/wiki/B-tree">B-tree</a>.</p>
<h2 id="when-the-pgm-index-fits-in-main-memory">When the PGM-index fits in main memory</h2>
<p>We can relax the assumption made at the beginning of this article, i.e. that PGM-index is kept on disk alongside the $n$ input keys. Indeed, it is reasonable to assume that the PGM-index fits in the internal memory.</p>
<p>Let $C$ denote the size of a CPU cache line (typically 64 bytes). We can construct a PGM-index so that (i) it searches in its internal levels by minimising the number of cache misses, and (ii) it returns the disk page where the sought key falls into, so that only $\Oh(1)$ disk I/Os are needed.<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>
In this scenario, the PGM-index achieves the following bounds in the worst case:</p>
<p><strong>Number of levels:</strong> $\Oh(\log_C n)$<br>
<strong>Point query:</strong> $\Oh(\log_C n)$ cache misses + $\Oh(1)$ disk I/Os<br>
<strong>Range query:</strong> $\Oh(\log_C n)$ cache misses + $\Oh(\frac{k}{B})$ disk I/Os, where $k$ is the number of reported keys<br>
<strong>Space of the index:</strong> $\Oh(\frac{n}{B})$ memory words, i.e. $\Oh(\frac{n}{B^2})$ disk pages</p>
<p>Actually, even when built on large datasets, the PGM-index can fit in the CPU cache (see the plots in <a href="/slides-pgm-index-vldb.pdf">our slides</a>), so the number of cache misses can be just $\Oh(1)$!</p>
<h2 id="on-the-space-complexity">On the space complexity</h2>
<p>In our experiments, the performance of the PGM-index was better than what the previous bounds show, particularly for what concerns the space of the index, which above we bounded as $\Oh(\frac{n}{B})$ memory words. This motivated us to study what happens to the space occupancy of the PGM-index when one makes some general assumptions on the input data.</p>
<p>In our ICML20 paper <a href="http://pages.di.unipi.it/vinciguerra/publication/learned-indexes-effectiveness/">Why are learned indexes so effective?</a>, we found that, if we assume that the gaps between input sorted keys are taken from a distribution with finite mean and variance, then the space of the PGM-index converges to $\Oh(\frac{n}{B^2})$ memory words, i.e. $\Oh(\frac{n}{B^3})$ disk pages (versus $\Theta(\frac{n}{B^2})$ disk pages of B-trees).
This result applies to <em>any</em> distribution (such as Uniform, Lognormal, Pareto, Exponential, and Gamma), as long as the mean and variance of the random variables modelling the gaps are finite.</p>
<p><strong>Space of the index:</strong> converges to $\Oh(\frac{n}{B^2})$ memory words, i.e. $\Oh(\frac{n}{B^3})$ disk pages</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>A good survey on this topic is &ldquo;External Memory Algorithms and Data Structures: Dealing with Massive Data&rdquo; by Jeffrey Scott Vitter. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>One can inspect $m$ by calling the <a href="https://pgm.di.unipi.it/docs/cpp-reference/#classpgm_1_1_p_g_m_index_1ab31ba6049ebca19dc403ac93b44de975"><code>segments_count()</code></a> method. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>See Lemma 2 and Section 2.2 of the <a href="http://www.vldb.org/pvldb/vol13/p1162-ferragina.pdf">VLDB paper</a>. <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>This is possible by setting the <code>Epsilon</code> and <code>EpsilonRecursive</code> template parameters of the <a href="https://pgm.di.unipi.it/docs/cpp-reference/#classpgm_1_1_p_g_m_index"><code>pgm::PGMIndex</code></a> class to a multiple of $B/2$ and $C/2$, respectively. For example, since both template parameters are expressed in number of keys, if the data consists of a sequence of $b$-byte keys stored contiguously in $B$-byte disk pages, then one could set <code>Epsilon</code> to a multiple of <code>B/(2*b)</code>. <a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

</div>
</div>

        </div>
      </div>
    </div>
    
  </div>

  <div class="footer">
  Made with 👼 at <a href="https://www.di.unipi.it/en/">University of Pisa</a> by the <a
    href="http://acube.di.unipi.it">A³ Lab</a>
</div>
<link rel="stylesheet" href="/js/katex/katex.min.css">
<script defer src="/js/katex/katex.min.js"></script>
<script defer src="/js/katex/auto-render.min.js" onload="renderMathInElement(document.body, { macros: { '\\Oh': '\\mathcal{O}' }, delimiters: [
  {left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}] });"></script>

  

  
  

  
  <script type="text/javascript" src="/js/scripts.min.1237ff71925bb8625c97a9af8db4c54525258bedfd7c47493daaff723bea755e.js"></script>
  

  
  
  
    
  


</body>

</html>
